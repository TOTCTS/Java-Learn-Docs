---
description: 
globs: 
alwaysApply: true
---
# Cursor 规则

## 项目功能描述
- 这是一份深入学习Java的纯文档项目
- 这份文档主要面向Java初学者、Java开发人员、资深开发人员
- 内容将涵盖以下主要技术栈：
  - **核心语言:** Java (JVM, 并发编程, 集合框架)
  - **主流框架:** Spring, Spring Boot, Spring Cloud, Spring MVC, MyBatis, Netty
  - **数据库技术:** MySQL, PostgreSQL, Redis, MongoDB
  - **消息队列 (MQ):** RabbitMQ, Kafka
  - **搜索引擎:** Elasticsearch
  - **容器化与微服务:** Docker, Kubernetes (K8s), 微服务架构
  - **工程化与DevOps:** Maven, Gradle, Git, Jenkins

## 项目结构
- 所有文档源文件应存放在 `docs` 目录下。
- 文档根据技术类别创建子目录，例如：`docs/java/`, `docs/spring/`。

## 文件命名规范
- 所有 Markdown 文件和目录名应使用全小写英文字母。
- 单词之间使用短横线 (`-`) 连接，例如：`spring-boot-quick-start.md`。

## 行文风格与措辞
- 内容需面向不同水平的读者（初学者、资深开发者）。
- 面向初学者的内容应通俗易懂，避免生僻术语。
- 面向资深开发者的内容应保持技术深度、专业性和严谨性。 
- **技术阐述的严谨性**: 在【详细讲解】等需要深入技术细节的章节中，应优先使用**严谨、客观、过程导向**的标题和术语。避免使用过于文学化、戏剧化或拟人化的比喻（例如"舞台剧"、"序幕"），以确保技术描述的专业性和清晰度。标题和内容应直接反映技术过程本身。

## 文档要求
- 使用 Markdown (`.md`) 作为主要文档格式。
- 采用静态网站生成器 (Static Site Generator) 进行构建和发布。
- 文档需支持通过 SVG 图表生成流程图、时序图等。
- 最终生成的文档网站应具备美观的样式和良好的阅读体验。 
- 文档组成结构为大纲，大纲中涉及很多知识点，每个知识点对应新开一份文档专门描述
- **最终布局要求**：尽管创作过程遵循"先内容后图表"的原则，但最终面向读者的文章布局应将**核心架构图或高级概览图置于文章开篇位置**。这有助于读者第一时间建立对主题的宏观理解。其他如流程图、时序图等更具体的图表，应嵌入到其对应的详细讲解段落中，与上下文紧密结合。

## 知识点输出要求

### 核心原则：聚焦与深度 (Focus & Depth)
- **聚焦单一知识点**: 每个文档应严格围绕其核心主题。避免内容发散，不引入非强相关的技术点。
- **追求垂直深度**: 优先深入挖掘当前知识点的内部原理、设计决策和边界条件，而不是横向扩展到多个主题。
- **避免扩展知识点**: 严格控制内容边界，不主动引入当前主题之外的技术概念，即使相关度较高也应克制。

### 内容表达优先级 (Content Expression Priority)
**核心原则**: 坚持"**图表优先、文字详述、代码最少**"的表达策略，确保技术概念通过最直观的方式传达。

#### 表达方式优先级排序
1. **图表可视化 (首选)**：优先使用 SVG 图表展示技术概念
   - **架构图**: 展示系统结构、组件关系
   - **流程图**: 展示处理步骤、决策分支
   - **时序图**: 展示时间线上的交互过程
   - **状态图**: 展示状态变化和转换条件
   - **原理图**: 展示内部工作机制
   - **对比图**: 展示不同技术的差异

2. **详细文字描述 (次选)**：当图表无法完全表达时，使用深入的文字说明
   - **机制解释**: 详细说明工作原理和内部机制
   - **参数说明**: 解释关键参数的含义和影响
   - **场景分析**: 描述适用场景和使用条件
   - **性能特征**: 分析性能表现和优化策略

3. **代码片段 (慎用)**：仅在前两种方式无法清晰表达时才使用
   - **最小化原则**: 只提供理解核心概念必需的最少代码
   - **概念性优先**: 优先使用伪代码或概念性代码片段
   - **避免完整实现**: 不提供完整的、可运行的代码示例

### 内容创作流程 (Content-First Approach)
**核心原则**: 坚持"**先内容后图表**"的创作流程，确保图表真正服务于内容理解。

#### 第一阶段：内容创作
1. **完整编写文字内容**: 首先完成【核心讲解】和【详细讲解】的全部文字内容
2. **识别图表需求**: 在文字内容完成后，识别哪些概念、流程、架构需要图表支持
3. **确定图表类型**: 根据内容特点选择最合适的图表类型：
   - **架构概览**: 使用**系统架构图**展示整体结构和组件关系
   - **原理机制**: 使用**原理图**展示内部工作机制和数据流向
   - **动态过程**: 使用**流程图**或**时序图**展示步骤和时间线
   - **对比分析**: 使用**对比图**展示不同技术的优劣势
   - **层次结构**: 使用**分层图**展示技术栈或组件层次

#### 第二阶段：图表设计与制作
1. **图表内容设计**: 基于已完成的文字内容，设计图表的具体内容和布局
2. **深度信息整合**: 图表不仅要**直观展示**，更要**深度解析**：
   - **技术细节标注**: 在图表中直接标注关键技术参数、算法复杂度等
   - **交互关系说明**: 清晰标示组件间的调用关系、数据传递方式
   - **性能指标展示**: 在适当位置标注性能数据、瓶颈点等关键信息
   - **故障点标识**: 标出容易出现问题的节点和常见故障类型
3. **图表制作**: 严格按照SVG规范制作高质量图表

#### 第三阶段：图文整合与优化
1. **图文对应检查**: 确保每个图表都与对应的文字内容**完美契合**
2. **信息一致性验证**: 图表中的信息必须与文字描述**完全一致**，避免矛盾
3. **补充说明**: 为复杂图表提供详细的**图表说明**，解释图中的关键元素

### 图表优先布局原则 (Diagram-First Layout)
**图表先行**: 为帮助读者快速建立宏观认知，每个知识点文档的最终成品应将核心的架构图或概览图置于文章开篇。此原则强调最终阅读体验，与"先内容后图表"的创作流程并行不悖。具体的细节图表（如流程图、时序图）则应随文嵌入，紧密配合文字说明。

### 图表深度要求 (Deep Visual Analysis)
**目标**: 图表不仅要"好看"，更要"深刻"，能够承载和传递复杂的技术信息。

#### 深度分析要求
- **内部机制可视化**: 不仅展示"是什么"，更要展示"怎么工作"
- **数据流向精确化**: 清晰标示数据的完整流转路径和处理步骤
- **异常处理可视化**: 在流程图中标出异常分支和处理机制
- **优化点标识**: 标出性能优化的关键节点和优化策略

### 图表更新与维护机制 (Chart Maintenance Protocol)
**原则**: 内容与图表必须保持同步，任何重要更新都要评估图表的更新需求。

#### 更新触发条件
当发生以下情况时，**必须**检查并考虑更新相关图表：
1. **核心概念修改**: 技术定义、工作原理发生变化
2. **架构调整**: 系统架构、组件关系发生变更
3. **流程优化**: 处理流程、算法逻辑发生改进
4. **参数变更**: 重要参数的默认值、推荐值发生变化
5. **版本升级**: 涉及的技术版本发生重大升级
6. **性能数据更新**: 性能基准、测试数据发生显著变化

#### 更新评估流程
1. **影响范围评估**: 确定内容变更对现有图表的影响程度
2. **更新必要性判断**: 评估是否需要更新图表，还是仅需调整说明文字
3. **更新优先级排序**: 根据图表的重要性和影响范围确定更新顺序
4. **更新实施**: 按照SVG规范重新制作或修改图表
5. **一致性验证**: 确保更新后的图表与文字内容完全一致

#### 版本控制要求
- **图表版本标识**: 重要图表应在SVG注释中标注版本和更新日期
- **变更日志**: 记录图表的主要变更内容和原因
- **回滚机制**: 保留重要图表的历史版本，以便必要时回滚

### 图文协同质量标准 (Content-Visual Synergy Standards)
#### 一致性要求
- **术语统一**: 图表中使用的术语必须与文字内容完全一致
- **数据一致**: 图表中的数值、参数必须与文字描述匹配
- **逻辑一致**: 图表展示的逻辑关系必须与文字阐述的逻辑一致

#### 互补性要求
- **信息互补**: 图表提供文字难以表达的直观信息，文字提供图表无法承载的深度分析
- **细节互补**: 图表展示宏观结构，文字深入微观细节
- **角度互补**: 图表从空间角度展示，文字从时间和逻辑角度阐述

### 各模块编写规范

#### 【核心讲解】编写要求
**目标**: 用最简洁的语言描述技术的**核心内容和原理**，回答"是什么"和"为什么需要"的问题。

**内容结构**:
1. **本质定义**: 用1-2句话精准定义技术的本质，避免循环定义和模糊表述
2. **核心价值**: 明确指出该技术解决的**根本问题**和**核心痛点**
3. **设计初衷**: 简述该技术诞生的**历史背景**和**设计哲学**

**编写原则**:
- **极简表达**: 用最少的语言描述最核心的内容
- **避免术语堆砌**: 每个专业术语都要有简洁的解释或类比
- **突出核心矛盾**: 重点说明该技术要解决的**核心矛盾**或**权衡取舍**
- **建立认知锚点**: 通过类比或对比，帮助读者建立**直观理解**
- **严格边界控制**: 不引入非核心的相关技术概念

#### 【详细讲解】编写要求
**目标**: 以专业论文的严谨性和连贯性，对核心内容和原理进行深度阐述，让读者全面理解知识点的完整体系。基于原始文档、官方规范和权威资料，提供准确、深入的技术分析。

**内容组织原则**:
- **论文式叙述**: 采用连贯的学术性描述，避免概念罗列和要点堆砌
- **原始资料为准**: 内容必须基于官方文档、技术规范、权威书籍等第一手资料
- **系统性阐述**: 从技术的设计理念出发，系统性地展开完整的技术体系
- **逻辑严密**: 按照技术的内在逻辑关系，形成严密的论证链条
- **避免碎片化**: 不使用碎片化的知识点堆叠，而是形成完整的知识体系
- **灵活结构**: 根据知识点的具体特点和内容来组织结构，不强制套用固定模板

**内容深度要求**:
根据知识点的特点，可以重点关注以下方面（不要求全部涵盖，选择最相关的进行深入阐述）：

- **设计理念与架构思想**: 技术诞生的背景、解决的核心问题、设计哲学
- **核心机制与工作原理**: 内部实现机制、关键算法、数据结构设计
- **技术特征与性能分析**: 性能表现、适用场景、限制条件
- **实现细节与优化策略**: 具体实现方式、优化技术、工程考量
- **演进历史与对比分析**: 技术发展脉络、与其他技术的对比
- **生产实践与工程应用**: 实际应用场景、最佳实践、故障排查

**质量标准**:
- **准确性**: 所有技术细节必须有明确的权威来源支撑
- **深度**: 不满足于表面描述，要深入到实现机制和设计原理
- **完整性**: 覆盖该知识点的核心方面和重要细节
- **连贯性**: 形成逻辑严密、层次清晰的完整论述
- **实用性**: 理论分析与实践应用相结合，具有实际指导价值

**编写原则**:
- **图表优先**: 优先使用图表展示架构、流程、原理等复杂概念
- **机制优于现象**: 重点解释**内部机制**，而不是表面现象
- **原理优于操作**: 深入**底层原理**，而不是简单的操作步骤
- **系统性思维**: 将知识点放在**整个技术体系**中进行阐述
- **实战导向**: 结合**真实场景**和**生产环境**的考量
- **严格边界控制**: 避免引入非核心的关联技术
- **量化优先原则**: 优先使用具体、量化的数据来支撑观点

#### 【生产实践深度】原则
- **适用场景**: 当讲解的知识点与**系统性能、资源管理、架构设计、并发控制或故障排查**强相关时（例如：JVM内存模型、GC算法、线程池、数据库连接池、消息队列等）。
- **编写要求**: 在上述场景下，**强烈推荐（Highly Recommended）** 文档中包含深入的实践指导内容。这可以是一个独立的章节（如 `### 生产实践考量`），也可以融入在【详细讲解】的各个部分。内容应力求覆盖：
    1.  **关键配置 (Key Configurations)**: 解释核心调优参数及其对系统行为的影响。
    2.  **监控指标 (Monitoring Metrics)**: 提供关键的监控项和告警阈值建议。
    3.  **常见陷阱与解决方案 (Common Pitfalls & Solutions)**: 分析典型的线上问题、诊断思路和解决方案。
- **目的**: 确保在需要深度的领域提供足够的实践价值，同时避免在基础语法等不相关的知识点上增加不必要的复杂性。

#### 【演进与对比】分析规范
- **适用场景**: 当讲解的技术点是另一项技术的**重要演进、替代品或存在明确竞争关系**的方案时（例如：元空间 vs. 永久代, G1 vs. CMS, gRPC vs. RESTful API）。
- **编写要求**: 在此场景下，进行深度对比分析是**必要的**。强烈推荐使用表格形式，从多维度进行结构化对比。
- **目的**: 确保在关键的技术选型和历史演进部分，为读者提供最清晰的决策依据。

#### 【关联知识点处理规范】
**必要性原则**：仅在关联知识点对于理解当前主题**不可或缺**时才进行阐述。此时，应遵循以下规范：

1. **关联性质说明**: 明确两个技术之间是**依赖关系**、**互补关系**还是**竞争关系**
2. **交互界面分析**: 详细说明两个技术在**接口层面**的**交互方式**和**数据交换格式**
3. **协同工作机制**: 解释两个技术如何**协同工作**，各自承担什么**职责**
4. **集成复杂度**: 分析集成的**技术难点**和**常见问题**
5. **性能影响**: 说明关联技术对**整体性能**的**影响**和**优化策略**

#### 【核心代码片段】编写要求
**目标**: 仅在**无法用文字或图表清晰表达**核心逻辑时，才使用最简化的代码片段作为辅助说明。其唯一目的是**辅助理解**，而非提供可运行的解决方案。

**使用限制**:
- **严格必要性**: 只有在图表和文字描述都无法清晰表达时才使用
- **最小化原则**: 只提供理解核心概念**所必需的最少代码**
- **概念性优先**: 优先使用**伪代码**或**概念性代码片段**
- **避免完整实现**: 绝对不提供完整的、可运行的代码示例

**编写原则**:
1. **片段化优先**: 优先使用**关键方法或逻辑块**而非完整的类
2. **伪代码可行性**: 如果伪代码能够清晰地说明问题，则应优先使用伪代码
3. **无执行要求**: 提供的代码片段**不要求**必须能够独立编译或运行
4. **删除冗余**: 必须删除所有模板代码、日志、非核心的异常处理等

### 实施指导原则
#### 创作顺序强制要求
1. **第一步**: 完成所有文字内容（【核心讲解】、【详细讲解】）
2. **第二步**: 基于完成的文字内容，识别需要图表支持的具体内容点
3. **第三步**: 设计图表的具体内容、布局和技术细节
4. **第四步**: 制作高质量的SVG图表
5. **第五步**: 将图表与文字内容进行整合和优化
6. **第六步**: 仅在必要时添加最少的代码片段

#### 质量检查清单
- [ ] 文字内容是否完整且深入？
- [ ] 是否已最大化利用图表展示复杂概念？
- [ ] 代码片段是否已减少到最少？
- [ ] 图表需求是否已准确识别？
- [ ] 图表类型选择是否合适？
- [ ] 图表信息密度是否足够？
- [ ] 图表与文字内容是否一致？
- [ ] 图表是否能独立传达核心信息？
- [ ] 是否避免了不必要的知识点扩展？
- [ ] 是否需要更新现有图表？

## 资源文件组织规范 (Asset Organization)
- **目标**: 确保所有资源文件（如图表、图片等）的存储路径与其关联的 Markdown 文档路径保持一致，便于管理和维护。
- **存储规则**:
    - 所有 SVG 图表、图片等资源文件，必须存放在 `docs/public/assets/` 目录下。
    - 在 `assets` 目录下，应创建与 `docs` 目录中 Markdown 文件相对应的子目录结构。
- **示例**:
    - **文档路径**: `docs/java/jvm/jvm-memory-structure.md`
    - **对应资源路径**: `docs/public/assets/java/jvm/jvm-memory-structure-diagram.svg`
- **引用规则**: 在 Markdown 文件中引用资源时，应使用相对于 `public` 目录的根路径，例如 `/assets/java/jvm/your-diagram.svg`。

## 双重兼容性规范 (Dual Compatibility Standards)
**核心原则**: 项目需要同时支持 GitHub 和 VitePress 两个平台的完美显示，确保在任何平台上都能正常访问文档内容和图片资源。

### **路径兼容性策略 (Path Compatibility Strategy)**

#### **图片路径统一标准**
- **标准格式**: 所有 Markdown 文件中的图片路径**必须**使用 `/docs/public/assets/...` 格式
- **GitHub 解析**: GitHub 会将此路径解析为 `https://github.com/TOTCTS/Java-Learn-Docs/blob/main/docs/public/assets/...`
- **VitePress 解析**: 通过 Vite 别名配置，将 `/docs/public` 映射到 `/public`，确保 VitePress 能正确解析

#### **内部链接统一标准**
- **标准格式**: 所有内部文档链接**必须**使用相对路径格式，例如：
  - `./concurrent/thread-lifecycle-and-states.md`
  - `../jvm/jvm-memory-structure.md`
- **GitHub 解析**: GitHub 会自动解析相对路径为完整的 GitHub 路径
- **VitePress 解析**: VitePress 会自动添加 `.html` 扩展名并处理路径

#### **VitePress 配置要求**
- **路径别名**: 必须在 `docs/.vitepress/config.ts` 中配置路径别名：
  ```typescript
  vite: {
    resolve: {
      alias: {
        '/docs/public': '/public'
      }
    }
  }
  ```
- **基础路径**: 不设置 `base` 路径，避免路径冲突
- **侧边栏配置**: 使用不带 `/docs/` 前缀的路径

#### **文件组织要求**
- **文档位置**: 所有 Markdown 文件存放在 `docs/` 目录及其子目录中
- **资源位置**: 所有图片、SVG 等资源文件存放在 `docs/public/assets/` 目录中
- **路径映射**: 资源文件的目录结构应与文档结构保持一致

### **兼容性验证流程 (Compatibility Verification Process)**

#### **GitHub 兼容性检查**
1. **图片显示**: 确保所有图片在 GitHub 上正常显示，无 404 错误
2. **内部链接**: 验证所有内部链接能正确跳转到对应的文档页面
3. **路径正确性**: 确保链接包含正确的 `docs/` 前缀和文件扩展名

#### **VitePress 兼容性检查**
1. **本地开发**: 确保 `npm run docs:dev` 能正常启动，无路径错误
2. **图片显示**: 验证所有图片在 VitePress 中正常显示
3. **内部链接**: 确保所有内部链接能正确跳转，自动添加 `.html`

## SVG 图表规范
- **黄金标准参考 (Golden Standard Reference)**: **`docs/public/assets/java/jvm/jvm-memory-structure-diagram.svg`** 被确立为本项目所有图表设计的"黄金标准"。所有新图表在视觉风格、布局逻辑、信息密度和美学细节上，都应以此为目标进行看齐。

- **核心设计原则 (Core Design Principles)**:
  - **逻辑分区 (Zoning & Grouping)**: 优先使用大型、带有浅色透明背景的面板来对顶层概念进行逻辑分区 (例如，线程共享区 vs. 私有区)。这有助于建立图表的宏观结构。
  - **视觉层次 (Visual Hierarchy)**: 通过嵌套和样式变化来明确信息层级。
    - **主区域**: 使用带有实线边框和微妙渐变的面板。
    - **子区域**: 在主区域内使用带有虚线边框的面板来表示其组成部分。
    - **具体条目**: 在子区域内使用更小的、无边框或细边框的矩形来展示具体信息点。
  - **结构化表达**: 列表式信息应使用结构化的图形元素（如带有项目符号或编号的左对齐列表）呈现，避免简单的多行居中文字。
  - **简洁性**: 避免在图表内使用与文档标题重复的标题性文字，让图表专注于核心信息。
  - **视觉间距 (Breathing Room)**: 保证所有元素之间有足够的视觉间距，避免拥挤和重叠。

- **色彩与风格体系 (Color & Style System)**:
  - **推荐调色板 (Recommended Palettes)**:
    - **核心/数据区 (如 Heap)**: 暖色调渐变，如 `#FFDDC1` -> `#FFC3A0`。
    - **执行/逻辑区 (如 Stack)**: 冷色调渐变，如 `#D4F1F4` -> `#A9D3E0`。
    - **元数据/定义区 (如 Metaspace)**: 中性色调渐变，如 `#EAEAEA` -> `#DCDCDC`。
    - **顶层分区背景**: 使用半透明的浅色，如 `rgba(255, 248, 225, 0.5)` (淡奶油) 或 `rgba(225, 245, 254, 0.5)` (淡青)。
  - **字体**: 使用 `Inter` 或 `Arial` 等无衬线字体。通过字重 (font-weight) 和字号 (font-size) 来区分标题、副标题和正文。

- **兼容性与编写规范 (Compatibility & Authoring Standards)**:
  - **兼容性**: SVG 图表应在所有现代浏览器和平台（GitHub, VitePress）上正常显示。
  - **严谨性优先**: 手动编写 SVG 时，必须符合 W3C 规范。
  - **ID 唯一性**: 同一 SVG 文件中，所有 `id` 属性必须唯一。
  - **XML 实体编码**: `<text>` 标签中的特殊字符必须转义 (e.g., `<` 写作 `&lt;`)。
  - **浏览器验证**: 每次修改后，必须在浏览器中直接打开 SVG 文件进行渲染验证。