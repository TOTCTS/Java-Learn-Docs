# Cursor 规则

## 项目功能描述
- 这是一份深入学习Java的纯文档项目
- 这份文档主要面向Java初学者、Java开发人员、资深开发人员
- 内容将涵盖以下主要技术栈：
  - **核心语言:** Java (JVM, 并发编程, 集合框架)
  - **主流框架:** Spring, Spring Boot, Spring Cloud, Spring MVC, MyBatis, Netty
  - **数据库技术:** MySQL, PostgreSQL, Redis, MongoDB
  - **消息队列 (MQ):** RabbitMQ, Kafka
  - **搜索引擎:** Elasticsearch
  - **容器化与微服务:** Docker, Kubernetes (K8s), 微服务架构
  - **工程化与DevOps:** Maven, Gradle, Git, Jenkins

## 项目结构
- 所有文档源文件应存放在 `docs` 目录下。
- 文档根据技术类别创建子目录，例如：`docs/java/`, `docs/spring/`。

## 文件命名规范
- 所有 Markdown 文件和目录名应使用全小写英文字母。
- 单词之间使用短横线 (`-`) 连接，例如：`spring-boot-quick-start.md`。

## 行文风格与措辞
- 内容需面向不同水平的读者（初学者、资深开发者）。
- 面向初学者的内容应通俗易懂，避免生僻术语。
- 面向资深开发者的内容应保持技术深度、专业性和严谨性。 
- **技术阐述的严谨性**: 在【详细讲解】等需要深入技术细节的章节中，应优先使用**严谨、客观、过程导向**的标题和术语。避免使用过于文学化、戏剧化或拟人化的比喻（例如"舞台剧"、"序幕"），以确保技术描述的专业性和清晰度。标题和内容应直接反映技术过程本身。

## 文档要求
- 使用 Markdown (`.md`) 作为主要文档格式。
- 采用静态网站生成器 (Static Site Generator) 进行构建和发布。
- 文档需支持通过 SVG 图表生成流程图、时序图等。
- 最终生成的文档网站应具备美观的样式和良好的阅读体验。 
- 文档组成结构为大纲，大纲中涉及很多知识点，每个知识点对应新开一份文档专门描述
- **最终布局要求**：尽管创作过程遵循"先内容后图表"的原则，但最终面向读者的文章布局应将**核心架构图或高级概览图置于文章开篇位置**。这有助于读者第一时间建立对主题的宏观理解。其他如流程图、时序图等更具体的图表，应嵌入到其对应的详细讲解段落中，与上下文紧密结合。

## 知识点输出要求

### 核心原则：聚焦与深度 (Focus & Depth)
- **聚焦单一知识点**: 每个文档应严格围绕其核心主题。避免内容发散，不引入非强相关的技术点。
- **追求垂直深度**: 优先深入挖掘当前知识点的内部原理、设计决策和边界条件，而不是横向扩展到多个主题。
- **避免扩展知识点**: 严格控制内容边界，不主动引入当前主题之外的技术概念，即使相关度较高也应克制。

### 内容表达优先级 (Content Expression Priority)
**核心原则**: 坚持"**图表优先、文字详述、代码最少**"的表达策略，确保技术概念通过最直观的方式传达。

#### 表达方式优先级排序
1. **图表可视化 (首选)**：优先使用 SVG 图表展示技术概念
   - **架构图**: 展示系统结构、组件关系
   - **流程图**: 展示处理步骤、决策分支
   - **时序图**: 展示时间线上的交互过程
   - **状态图**: 展示状态变化和转换条件
   - **原理图**: 展示内部工作机制
   - **对比图**: 展示不同技术的差异

2. **详细文字描述 (次选)**：当图表无法完全表达时，使用深入的文字说明
   - **机制解释**: 详细说明工作原理和内部机制
   - **参数说明**: 解释关键参数的含义和影响
   - **场景分析**: 描述适用场景和使用条件
   - **性能特征**: 分析性能表现和优化策略

3. **代码片段 (慎用)**：仅在前两种方式无法清晰表达时才使用
   - **最小化原则**: 只提供理解核心概念必需的最少代码
   - **概念性优先**: 优先使用伪代码或概念性代码片段
   - **避免完整实现**: 不提供完整的、可运行的代码示例

### 内容创作流程 (Content-First Approach)
**核心原则**: 坚持"**先内容后图表**"的创作流程，确保图表真正服务于内容理解。

#### 第一阶段：内容创作
1. **完整编写文字内容**: 首先完成【核心讲解】和【详细讲解】的全部文字内容
2. **识别图表需求**: 在文字内容完成后，识别哪些概念、流程、架构需要图表支持
3. **确定图表类型**: 根据内容特点选择最合适的图表类型：
   - **架构概览**: 使用**系统架构图**展示整体结构和组件关系
   - **原理机制**: 使用**原理图**展示内部工作机制和数据流向
   - **动态过程**: 使用**流程图**或**时序图**展示步骤和时间线
   - **对比分析**: 使用**对比图**展示不同技术的优劣势
   - **层次结构**: 使用**分层图**展示技术栈或组件层次

#### 第二阶段：图表设计与制作
1. **图表内容设计**: 基于已完成的文字内容，设计图表的具体内容和布局
2. **深度信息整合**: 图表不仅要**直观展示**，更要**深度解析**：
   - **技术细节标注**: 在图表中直接标注关键技术参数、算法复杂度等
   - **交互关系说明**: 清晰标示组件间的调用关系、数据传递方式
   - **性能指标展示**: 在适当位置标注性能数据、瓶颈点等关键信息
   - **故障点标识**: 标出容易出现问题的节点和常见故障类型
3. **图表制作**: 严格按照SVG规范制作高质量图表

#### **开篇概览图制作流程**
1. **概念提取**: 从文字内容中提取**核心概念**和**主要组件**
2. **结构简化**: 将复杂的技术关系**抽象为简单的层次结构**或**逻辑分组**
3. **视觉设计**: 使用**大面板**、**清晰标题**和**简洁连线**
4. **信息筛选**: **严格控制**信息密度，只保留**最核心**的概念和关系
5. **认知验证**: 确保**非专业读者**也能快速理解图表要表达的核心思想

#### **详细讲解图表制作流程**
1. **机制分析**: 深入分析需要可视化的**具体工作机制**和**技术细节**
2. **图表类型选择**: 根据内容特点选择**最合适的图表类型**：
   - **流程图**: 展示**步骤序列**和**决策分支**
   - **时序图**: 展示**时间线**上的**交互过程**
   - **状态图**: 展示**状态变化**和**转换条件**
   - **架构图**: 展示**组件关系**和**数据流向**
3. **细节整合**: 在图表中整合**技术参数**、**性能数据**、**配置选项**等详细信息
4. **上下文匹配**: 确保图表与对应的文字段落**完美契合**
5. **渐进式设计**: 按照文章的逻辑顺序，**逐步增加**图表的复杂度和细节深度

#### 第三阶段：图文整合与优化
1. **图文对应检查**: 确保每个图表都与对应的文字内容**完美契合**
2. **信息一致性验证**: 图表中的信息必须与文字描述**完全一致**，避免矛盾
3. **补充说明**: 为复杂图表提供详细的**图表说明**，解释图中的关键元素

### 图表优先布局原则 (Diagram-First Layout)
**图表先行**: 为帮助读者快速建立宏观认知，每个知识点文档的最终成品应将核心的架构图或概览图置于文章开篇。此原则强调最终阅读体验，与"先内容后图表"的创作流程并行不悖。具体的细节图表（如流程图、时序图）则应随文嵌入，紧密配合文字说明。

#### **开篇概览图设计原则**
**目标**: 开篇图表应该**简洁明了**，快速传达**核心概念**和**整体架构**，避免过度复杂的细节。

**设计要求**:
- **高层次抽象**: 重点展示**主要组件**和**核心关系**，不深入具体实现细节
- **视觉清晰**: 使用**大块面板**和**清晰分区**，避免密集的文字和复杂的连线
- **概念导向**: 优先展示**"是什么"**和**"整体结构"**，而非**"怎么工作"**的具体步骤
- **认知友好**: 帮助读者在**30秒内**建立对主题的**宏观理解**
- **简化表达**: 避免过多的技术参数、性能数据等详细信息

#### **详细讲解图表设计原则**
**目标**: 详细讲解中的图表应该**图文并茂**，提供**深度细节**和**具体机制**的可视化说明。

**设计要求**:
- **机制深入**: 详细展示**工作原理**、**执行流程**、**状态变化**等具体机制
- **信息丰富**: 可以包含**技术参数**、**性能指标**、**配置选项**等详细信息
- **多维度展示**: 使用**流程图**、**时序图**、**状态图**等多种图表类型
- **上下文结合**: 图表与对应的文字段落**紧密配合**，相互补充
- **渐进式复杂度**: 从简单概念到复杂实现，**逐步深入**

### 图表深度要求 (Deep Visual Analysis)
**目标**: 图表不仅要"好看"，更要"深刻"，能够承载和传递复杂的技术信息。

#### 深度分析要求
- **内部机制可视化**: 不仅展示"是什么"，更要展示"怎么工作"
- **数据流向精确化**: 清晰标示数据的完整流转路径和处理步骤
- **异常处理可视化**: 在流程图中标出异常分支和处理机制
- **优化点标识**: 标出性能优化的关键节点和优化策略

### 图表更新与维护机制 (Chart Maintenance Protocol)
**原则**: 内容与图表必须保持同步，任何重要更新都要评估图表的更新需求。

#### 更新触发条件
当发生以下情况时，**必须**检查并考虑更新相关图表：
1. **核心概念修改**: 技术定义、工作原理发生变化
2. **架构调整**: 系统架构、组件关系发生变更
3. **流程优化**: 处理流程、算法逻辑发生改进
4. **参数变更**: 重要参数的默认值、推荐值发生变化
5. **版本升级**: 涉及的技术版本发生重大升级
6. **性能数据更新**: 性能基准、测试数据发生显著变化

#### 更新评估流程
1. **影响范围评估**: 确定内容变更对现有图表的影响程度
2. **更新必要性判断**: 评估是否需要更新图表，还是仅需调整说明文字
3. **更新优先级排序**: 根据图表的重要性和影响范围确定更新顺序
4. **更新实施**: 按照SVG规范重新制作或修改图表
5. **一致性验证**: 确保更新后的图表与文字内容完全一致

#### 版本控制要求
- **图表版本标识**: 重要图表应在SVG注释中标注版本和更新日期
- **变更日志**: 记录图表的主要变更内容和原因
- **回滚机制**: 保留重要图表的历史版本，以便必要时回滚

### 图文协同质量标准 (Content-Visual Synergy Standards)
#### 一致性要求
- **术语统一**: 图表中使用的术语必须与文字内容完全一致
- **数据一致**: 图表中的数值、参数必须与文字描述匹配
- **逻辑一致**: 图表展示的逻辑关系必须与文字阐述的逻辑一致

#### 互补性要求
- **信息互补**: 图表提供文字难以表达的直观信息，文字提供图表无法承载的深度分析
- **细节互补**: 图表展示宏观结构，文字深入微观细节
- **角度互补**: 图表从空间角度展示，文字从时间和逻辑角度阐述

### 各模块编写规范

#### 【核心讲解】编写要求
**目标**: 用最简洁的语言直接描述技术的**核心内容和原理**，回答"是什么"和"为什么需要"的问题。

**编写原则**:
- **直接表达**：直接描述知识点的核心内容，不拘泥于固定的结构模板
- **核心聚焦**：重点说明该技术的**本质特征**和**根本价值**
- **简洁明了**：用最少的语言描述最核心的内容，避免冗余表述
- **避免术语堆砌**：每个专业术语都要有简洁的解释或类比
- **突出关键矛盾**：重点说明该技术要解决的**核心问题**或**权衡取舍**
- **建立认知锚点**：通过类比或对比，帮助读者建立**直观理解**
- **严格边界控制**：不引入非核心的相关技术概念

**内容要求**:
- **自然流畅**：按照最符合逻辑的方式组织内容，可以是原理阐述、问题分析、特征描述等任何合适的角度
- **核心优先**：优先描述最重要、最核心的概念和机制
- **读者友好**：考虑不同水平读者的理解需求，提供必要的背景说明

#### 【详细讲解】编写要求
**目标**: 以专业论文的严谨性和连贯性，对核心内容和原理进行深度阐述，让读者全面理解知识点的完整体系。基于原始文档、官方规范和权威资料，提供准确、深入的技术分析。

**内容组织原则**:
- **论文式叙述**: 采用连贯的学术性描述，避免概念罗列和要点堆砌
- **原始资料为准**: 内容必须基于官方文档、技术规范、权威书籍等第一手资料
- **系统性阐述**: 从技术的设计理念出发，系统性地展开完整的技术体系
- **逻辑严密**: 按照技术的内在逻辑关系，形成严密的论证链条
- **避免碎片化**: 不使用碎片化的知识点堆叠，而是形成完整的知识体系
- **自然组织**: 根据原始资料的逻辑和知识点的特点来组织结构，选择最合适的表达方式

**编写策略**:
- **资料导向**: 深入研读官方文档、技术规范等权威资料，按照其逻辑脉络组织内容
- **最佳表达**: 选择最能清晰传达技术本质的描述方式，不拘泥于固定模板
- **深度优先**: 优先深入挖掘技术的核心机制和设计原理
- **完整覆盖**: 确保涵盖该知识点的重要方面，形成完整的技术图景
- **实践结合**: 理论阐述与实际应用相结合，提供实用价值

**质量标准**:
- **准确性**: 所有技术细节必须有明确的权威来源支撑
- **深度**: 不满足于表面描述，要深入到实现机制和设计原理
- **完整性**: 覆盖该知识点的核心方面和重要细节
- **连贯性**: 形成逻辑严密、层次清晰的完整论述
- **实用性**: 理论分析与实践应用相结合，具有实际指导价值

**编写原则**:
- **图表优先**: 优先使用图表展示架构、流程、原理等复杂概念
- **机制优于现象**: 重点解释**内部机制**，而不是表面现象
- **原理优于操作**: 深入**底层原理**，而不是简单的操作步骤
- **系统性思维**: 将知识点放在**整个技术体系**中进行阐述
- **实战导向**: 结合**真实场景**和**生产环境**的考量
- **严格边界控制**: 避免引入非核心的关联技术
- **量化优先原则**: 优先使用具体、量化的数据来支撑观点

#### 【生产实践深度】原则
- **适用场景**: 当讲解的知识点与**系统性能、资源管理、架构设计、并发控制或故障排查**强相关时（例如：JVM内存模型、GC算法、线程池、数据库连接池、消息队列等）。
- **编写要求**: 在上述场景下，**强烈推荐（Highly Recommended）** 文档中包含深入的实践指导内容。这可以是一个独立的章节（如 `### 生产实践考量`），也可以融入在【详细讲解】的各个部分。内容应力求覆盖：
    1.  **关键配置 (Key Configurations)**: 解释核心调优参数及其对系统行为的影响。
    2.  **监控指标 (Monitoring Metrics)**: 提供关键的监控项和告警阈值建议。
    3.  **常见陷阱与解决方案 (Common Pitfalls & Solutions)**: 分析典型的线上问题、诊断思路和解决方案。
- **目的**: 确保在需要深度的领域提供足够的实践价值，同时避免在基础语法等不相关的知识点上增加不必要的复杂性。

#### 【演进与对比】分析规范
- **适用场景**: 当讲解的技术点是另一项技术的**重要演进、替代品或存在明确竞争关系**的方案时（例如：元空间 vs. 永久代, G1 vs. CMS, gRPC vs. RESTful API）。
- **编写要求**: 在此场景下，进行深度对比分析是**必要的**。强烈推荐使用表格形式，从多维度进行结构化对比。
- **目的**: 确保在关键的技术选型和历史演进部分，为读者提供最清晰的决策依据。

#### 【关联知识点处理规范】
**必要性原则**：仅在关联知识点对于理解当前主题**不可或缺**时才进行阐述。此时，应遵循以下规范：

1. **关联性质说明**: 明确两个技术之间是**依赖关系**、**互补关系**还是**竞争关系**
2. **交互界面分析**: 详细说明两个技术在**接口层面**的**交互方式**和**数据交换格式**
3. **协同工作机制**: 解释两个技术如何**协同工作**，各自承担什么**职责**
4. **集成复杂度**: 分析集成的**技术难点**和**常见问题**
5. **性能影响**: 说明关联技术对**整体性能**的**影响**和**优化策略**

#### 【核心代码片段】编写要求
**目标**: 仅在**无法用文字或图表清晰表达**核心逻辑时，才使用最简化的代码片段作为辅助说明。其唯一目的是**辅助理解**，而非提供可运行的解决方案。

**使用限制**:
- **严格必要性**: 只有在图表和文字描述都无法清晰表达时才使用
- **最小化原则**: 只提供理解核心概念**所必需的最少代码**
- **概念性优先**: 优先使用**伪代码**或**概念性代码片段**
- **避免完整实现**: 绝对不提供完整的、可运行的代码示例

**编写原则**:
1. **片段化优先**: 优先使用**关键方法或逻辑块**而非完整的类
2. **伪代码可行性**: 如果伪代码能够清晰地说明问题，则应优先使用伪代码
3. **无执行要求**: 提供的代码片段**不要求**必须能够独立编译或运行
4. **删除冗余**: 必须删除所有模板代码、日志、非核心的异常处理等

### 实施指导原则
#### 创作顺序强制要求
1. **第一步**: 完成所有文字内容（【核心讲解】、【详细讲解】）
2. **第二步**: 基于完成的文字内容，识别需要图表支持的具体内容点
3. **第三步**: 设计图表的具体内容、布局和技术细节
4. **第四步**: 制作高质量的SVG图表
5. **第五步**: 将图表与文字内容进行整合和优化
6. **第六步**: 仅在必要时添加最少的代码片段

#### 质量检查清单
- [ ] 文字内容是否完整且深入？
- [ ] 是否已最大化利用图表展示复杂概念？
- [ ] 代码片段是否已减少到最少？
- [ ] 图表需求是否已准确识别？
- [ ] 图表类型选择是否合适？
- [ ] 图表信息密度是否足够？
- [ ] 图表与文字内容是否一致？
- [ ] 图表是否能独立传达核心信息？
- [ ] 是否避免了不必要的知识点扩展？
- [ ] 是否需要更新现有图表？

#### **开篇概览图质量检查**
- [ ] 概览图是否**简洁明了**，避免过度复杂？
- [ ] 是否在**30秒内**传达了核心概念？
- [ ] 是否使用了**高层次抽象**，避免实现细节？
- [ ] 视觉设计是否**清晰易懂**，适合快速浏览？
- [ ] 是否帮助读者建立了**宏观认知框架**？

#### **详细讲解图表质量检查**
- [ ] 图表是否与对应文字段落**紧密结合**？
- [ ] 是否提供了**足够的技术细节**和**具体机制**？
- [ ] 图表类型选择是否**最适合**要表达的内容？
- [ ] 是否实现了**渐进式复杂度**，逐步深入？
- [ ] 图表是否**信息丰富**，支撑深度理解？

## 资源文件组织规范 (Asset Organization)
- **目标**: 确保所有资源文件（如图表、图片等）的存储路径与其关联的 Markdown 文档路径保持一致，便于管理和维护。
- **存储规则**:
    - 所有 SVG 图表、图片等资源文件，必须存放在 `docs/public/assets/` 目录下。
    - 在 `assets` 目录下，应创建与 `docs` 目录中 Markdown 文件相对应的子目录结构。
- **示例**:
    - **文档路径**: `docs/java/jvm/jvm-memory-structure.md`
    - **对应资源路径**: `docs/public/assets/java/jvm/jvm-memory-structure-diagram.svg`
- **引用规则**: 在 Markdown 文件中引用资源时，应使用相对于 `public` 目录的根路径，例如 `/assets/java/jvm/your-diagram.svg`。

## 双重兼容性规范 (Dual Compatibility Standards)
**核心原则**: 项目需要同时支持 GitHub 和 VitePress 两个平台的完美显示，确保在任何平台上都能正常访问文档内容和图片资源。

### **路径兼容性策略 (Path Compatibility Strategy)**

#### **图片路径统一标准**
- **标准格式**: 所有 Markdown 文件中的图片路径**必须**使用 `/docs/public/assets/...` 格式
- **GitHub 解析**: GitHub 会将此路径解析为 `https://github.com/TOTCTS/Java-Learn-Docs/blob/main/docs/public/assets/...`
- **VitePress 解析**: 通过 Vite 别名配置，将 `/docs/public` 映射到 `/public`，确保 VitePress 能正确解析

#### **内部链接统一标准**
- **标准格式**: 所有内部文档链接**必须**使用相对路径格式，例如：
  - `./concurrent/thread-lifecycle-and-states.md`
  - `../jvm/jvm-memory-structure.md`
- **GitHub 解析**: GitHub 会自动解析相对路径为完整的 GitHub 路径
- **VitePress 解析**: VitePress 会自动添加 `.html` 扩展名并处理路径

#### **VitePress 配置要求**
- **路径别名**: 必须在 `docs/.vitepress/config.ts` 中配置路径别名：
  ```typescript
  vite: {
    resolve: {
      alias: {
        '/docs/public': '/public'
      }
    }
  }
  ```
- **基础路径**: 不设置 `base` 路径，避免路径冲突
- **侧边栏配置**: 使用不带 `/docs/` 前缀的路径

#### **文件组织要求**
- **文档位置**: 所有 Markdown 文件存放在 `docs/` 目录及其子目录中
- **资源位置**: 所有图片、SVG 等资源文件存放在 `docs/public/assets/` 目录中
- **路径映射**: 资源文件的目录结构应与文档结构保持一致

### **兼容性验证流程 (Compatibility Verification Process)**

#### **GitHub 兼容性检查**
1. **图片显示**: 确保所有图片在 GitHub 上正常显示，无 404 错误
2. **内部链接**: 验证所有内部链接能正确跳转到对应的文档页面
3. **路径正确性**: 确保链接包含正确的 `docs/` 前缀和文件扩展名

#### **VitePress 兼容性检查**
1. **本地开发**: 确保 `npm run docs:dev` 能正常启动，无路径错误
2. **图片显示**: 验证所有图片在 VitePress 中正常显示
3. **内部链接**: 确保所有内部链接能正确跳转，自动添加 `.html`

## SVG 图表规范
- **黄金标准参考 (Golden Standard Reference)**: **`docs/public/assets/java/jvm/jvm-memory-structure-diagram.svg`** 被确立为本项目所有图表设计的"黄金标准"。所有新图表在视觉风格、布局逻辑、信息密度和美学细节上，都应以此为目标进行看齐。

- **核心设计原则 (Core Design Principles)**:
  - **逻辑分区 (Zoning & Grouping)**: 优先使用大型、带有浅色透明背景的面板来对顶层概念进行逻辑分区 (例如，线程共享区 vs. 私有区)。这有助于建立图表的宏观结构。
  - **视觉层次 (Visual Hierarchy)**: 通过嵌套和样式变化来明确信息层级。
    - **主区域**: 使用带有实线边框和微妙渐变的面板。
    - **子区域**: 在主区域内使用带有虚线边框的面板来表示其组成部分。
    - **具体条目**: 在子区域内使用更小的、无边框或细边框的矩形来展示具体信息点。
  - **结构化表达**: 列表式信息应使用结构化的图形元素（如带有项目符号或编号的左对齐列表）呈现，避免简单的多行居中文字。
  - **简洁性**: 避免在图表内使用与文档标题重复的标题性文字，让图表专注于核心信息。
  - **视觉间距 (Breathing Room)**: 保证所有元素之间有足够的视觉间距，避免拥挤和重叠。

- **色彩与风格体系 (Color & Style System)**:
  - **推荐调色板 (Recommended Palettes)**:
    - **核心/数据区 (如 Heap)**: 暖色调渐变，如 `#FFDDC1` -> `#FFC3A0`。
    - **执行/逻辑区 (如 Stack)**: 冷色调渐变，如 `#D4F1F4` -> `#A9D3E0`。
    - **元数据/定义区 (如 Metaspace)**: 中性色调渐变，如 `#EAEAEA` -> `#DCDCDC`。
    - **顶层分区背景**: 使用半透明的浅色，如 `rgba(255, 248, 225, 0.5)` (淡奶油) 或 `rgba(225, 245, 254, 0.5)` (淡青)。
  - **字体**: 使用 `Inter` 或 `Arial` 等无衬线字体。通过字重 (font-weight) 和字号 (font-size) 来区分标题、副标题和正文。

- **兼容性与编写规范 (Compatibility & Authoring Standards)**:
  - **兼容性**: SVG 图表应在所有现代浏览器和平台（GitHub, VitePress）上正常显示。
  - **严谨性优先**: 手动编写 SVG 时，必须符合 W3C 规范。
  - **ID 唯一性**: 同一 SVG 文件中，所有 `id` 属性必须唯一。
  - **XML 实体编码**: `<text>` 标签中的特殊字符必须转义 (e.g., `<` 写作 `&lt;`)。
  - **浏览器验证**: 每次修改后，必须在浏览器中直接打开 SVG 文件进行渲染验证。