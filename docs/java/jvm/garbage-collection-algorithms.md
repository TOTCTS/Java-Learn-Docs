---
title: "垃圾回收基础算法：标记-清除、复制、标记-整理"
---

# 垃圾回收基础算法：标记-清除、复制、标记-整理

![垃圾回收算法概览](/docs/public/assets/java/jvm/garbage-collection-algorithms-overview.svg)

## 【核心讲解】

垃圾回收算法是 JVM 自动内存管理的核心机制，解决"如何自动识别并回收不再使用的内存对象"这一根本问题。现代垃圾收集器都基于三种基础算法：**标记-清除**、**复制**和**标记-整理**，它们在处理方式上体现了不同的设计哲学。

标记-清除算法采用**就地回收**策略：先标记所有存活对象，然后清除未标记的垃圾对象，保持对象原有位置不变。这种方式空间利用率高，但会产生内存碎片。

复制算法采用**迁移回收**策略：将存活对象从一个区域复制到另一个区域，然后清空原区域。这种方式彻底消除碎片，分配效率极高，但需要预留额外空间。

标记-整理算法采用**压缩回收**策略：先标记存活对象，然后将它们向内存一端移动，最后清理边界外的空间。这种方式既消除碎片又节省空间，但移动对象的开销较大。

三种算法的选择主要取决于**对象存活率**：存活率越低，复制算法越有优势；存活率越高，标记-整理算法越适合；而标记-清除算法则适用于空间敏感的场景。

---

## 【详细讲解】

### 算法原理与实现机制

垃圾回收算法的设计源于对程序内存使用模式的深入观察。根据 IBM 和 Oracle 的大量实证研究，绝大多数对象的生命周期呈现明显的分布特征：约 98% 的对象在分配后很快成为垃圾，而存活下来的对象往往具有较长的生命周期。这一观察直接影响了三种基础算法的设计方向。

![标记-清除算法工作原理](/docs/public/assets/java/jvm/mark-sweep-algorithm-detail.svg)

**标记-清除算法的实现基于可达性分析理论**。算法分为两个阶段：标记阶段从 GC Roots 开始，通过引用链遍历所有可达对象并进行标记；清除阶段扫描整个堆空间，回收所有未被标记的对象。现代实现中，标记过程通常采用三色标记法来支持并发执行：白色表示未访问对象，灰色表示已访问但其引用对象未完全扫描的对象，黑色表示已完全处理的对象。

清除阶段的实现涉及空闲内存的管理策略。最简单的实现是维护一个空闲链表，记录所有可用的内存块。当需要分配新对象时，从链表中搜索合适大小的空闲块。这种方式的主要问题是内存碎片：频繁的分配和回收会产生大量小的不连续空闲块，导致无法分配大对象，即使总的空闲空间足够。

![复制算法工作原理](/docs/public/assets/java/jvm/copying-algorithm-detail.svg)

**复制算法的设计灵感来自双缓冲技术**。算法将可用内存分为大小相等的两个区域，称为 From 空间和 To 空间。所有对象最初都在 From 空间中分配。垃圾回收时，算法遍历 From 空间中的所有存活对象，将它们复制到 To 空间，然后清空整个 From 空间。复制完成后，From 空间和 To 空间的角色互换。

复制过程中最关键的技术挑战是引用更新。当一个对象被复制到新位置后，所有指向该对象的引用都需要更新为新地址。经典的 Cheney 算法通过广度优先遍历来解决这个问题：它使用 To 空间本身作为队列，维护两个指针 scan 和 free，scan 指向下一个需要处理的已复制对象，free 指向下一个可用的空闲位置。

![标记-整理算法工作原理](/docs/public/assets/java/jvm/mark-compact-algorithm-detail.svg)

**标记-整理算法结合了前两种算法的优点**。标记阶段与标记-清除算法相同，但在清除阶段之前增加了整理阶段。整理的目标是将所有存活对象移动到内存的一端，使空闲内存形成连续的大块。

整理过程通常分为三个步骤：首先计算每个存活对象的新地址，然后更新所有对象内部的引用指针，最后实际移动对象数据。地址计算可以通过一次线性扫描完成，为每个存活对象分配新的连续地址。引用更新需要再次遍历所有对象，将每个引用字段调整为目标对象的新地址。

### 性能特征与适用场景

三种算法在不同场景下的性能表现存在显著差异，这主要取决于对象存活率、堆大小和硬件特征等因素。

![算法性能对比分析](/docs/public/assets/java/jvm/algorithm-performance-comparison.svg)

**标记-清除算法的性能特征**主要体现在其时间复杂度与存活对象数量和堆大小都相关。标记阶段的时间复杂度为 O(Live)，其中 Live 是存活对象的数量；清除阶段的时间复杂度为 O(Heap)，需要扫描整个堆空间。算法的空间开销最小，不需要额外的内存空间，但内存分配效率会随着碎片增加而降低。

在实际应用中，标记-清除算法适用于内存空间受限的环境，特别是当系统无法承受 50% 的空间开销时。算法的另一个优势是实现相对简单，易于与现有的内存管理系统集成。

**复制算法的性能特征**在低存活率场景下表现卓越。算法的时间复杂度仅与存活对象数量相关，为 O(Live)，与堆的总大小无关。内存分配采用指针碰撞方式，效率极高，时间复杂度为 O(1)。算法的主要缺点是 50% 的空间利用率，这在内存昂贵或有限的环境中是不可接受的。

HotSpot 虚拟机在新生代中对复制算法进行了优化，采用 Eden + 2个 Survivor 的设计（默认比例 8:1:1），将空间利用率提升到 90%。当 Survivor 空间不足以容纳所有存活对象时，这些对象会直接进入老年代，这被称为"分配担保"机制。

**标记-整理算法的性能特征**介于前两者之间。算法的时间复杂度为 O(Live + Heap)，既要处理存活对象的移动，也要扫描整个堆空间。但算法的优势在于空间利用率接近 100%，且内存分配效率与复制算法相当。

在老年代这种对象存活率较高（通常 60-90%）的场景中，标记-整理算法是最优选择。复制大量存活对象的成本过高，而标记-清除算法的内存碎片问题会严重影响大对象的分配。

### 分代收集理论的实践应用

三种基础算法的组合应用形成了现代 JVM 的分代收集理论。这一理论基于对对象生命周期的统计观察，将堆内存分为不同的代，并在每个代中应用最适合的回收算法。

![分代收集理论应用](/docs/public/assets/java/jvm/generational-collection-theory.svg)

**弱分代假说**指出，绝大多数对象都是朝生夕死的。IBM 的研究表明，在典型的 Java 应用中，超过 98% 的对象在分配后的第一次 GC 中就会被回收。基于这一观察，新生代采用复制算法，能够以极低的成本回收大量垃圾。

**强分代假说**进一步指出，对象存活的时间越长，就越不容易死亡。这意味着进入老年代的对象通常具有较长的生命周期，存活率在 60-90% 之间。在这种场景下，标记-整理算法成为最优选择。

**跨代引用假说**观察到，跨代引用相对于同代引用来说占极少数。这一假说使得分代收集成为可能，因为在回收年轻代时，只需要考虑少量来自老年代的引用。现代 JVM 通过记忆集（Remembered Set）或卡表（Card Table）来高效跟踪这些跨代引用。

现代垃圾收集器如 G1、ZGC 和 Shenandoah 进一步发展了这些基础算法。它们通过区域化管理、并发回收和增量收集等技术，在保持算法核心优势的同时，显著降低了 GC 暂停时间。

### 工程实践与性能调优

在实际的生产环境中，垃圾回收算法的选择和优化需要考虑应用特征、硬件环境和性能目标等多个维度。

![生产环境调优策略](/docs/public/assets/java/jvm/production-tuning-strategies.svg)

**内存分配模式分析**是优化的基础。不同的应用具有不同的对象分配模式：Web 应用通常有大量短生命周期的请求对象，适合使用高效的复制算法；科学计算应用可能有大量长生命周期的数据对象，更适合标记-整理算法；而嵌入式应用在内存受限的环境下，可能需要考虑标记-清除算法。

**GC 参数调优**需要基于具体的算法特征。对于新生代的复制算法，关键参数包括 `-XX:SurvivorRatio` 控制 Eden 与 Survivor 的比例，`-XX:MaxTenuringThreshold` 控制对象进入老年代的年龄阈值。对于老年代的标记-整理算法，重要参数包括各种收集器特定的触发阈值和并发线程数设置。

**性能监控指标**的建立对于算法性能评估至关重要。核心指标包括 GC 频率（每秒 GC 次数）、停顿时间（平均和最大暂停时间）、内存利用率（各代使用率）、分配速率（每秒分配的对象大小）等。通过 GCeasy、GCPlot 等工具可以对 GC 日志进行深度分析。

**故障排查策略**需要针对不同算法的特点。标记-清除算法的主要问题是内存碎片导致的分配失败，可以通过堆转储分析来识别碎片分布；复制算法的主要问题是 Survivor 区溢出导致的过早提升，需要关注提升率指标；标记-整理算法的主要问题是长时间暂停，需要分析移动对象的开销。

现代的 APM（应用性能监控）工具如 New Relic、AppDynamics 等提供了更高级的 GC 性能分析能力，能够自动识别性能瓶颈并提供调优建议。机器学习技术也开始被应用到 GC 调优中，通过分析历史数据来预测最优的参数配置。

---

**相关阅读**：
- [JVM 内存结构 (运行时数据区)](./jvm-memory-structure.md)
- [垃圾收集器：Serial、Parallel、CMS、G1、ZGC](./garbage-collectors-comparison.md)
- [对象的创建过程、内存布局与访问定位](./object-creation-and-memory-layout.md)

**下一步**：深入学习 [垃圾收集器对比](./garbage-collectors-comparison.md)，了解现代收集器如何组合运用这些基础算法。 