# 垃圾收集器深度对比：Serial、Parallel、CMS、G1、ZGC

<img src="https://cdn.jsdelivr.net/gh/TOTCTS/Java-Learn-Docs@main/docs/public/assets/java/jvm/garbage-collectors-architecture.svg" alt="垃圾收集器架构对比图" style="max-width: 800px; margin: 0 auto; display: block;"/>

## 【核心讲解】

垃圾收集器是 JVM 内存管理的**核心执行引擎**，负责**自动回收**不再使用的对象所占用的内存空间。其本质是在**程序执行**与**内存回收**之间进行**权衡调度**，通过不同的**算法策略**和**并发机制**来优化应用程序的**吞吐量**、**延迟**和**内存使用效率**。

### 核心价值与设计权衡

垃圾收集器解决的**根本问题**是在**有限内存**环境下的**内存生命周期管理**。不同收集器针对不同的**性能目标**和**应用场景**进行了**设计权衡**：

**Serial 收集器**：
- **核心痛点**：单线程环境下的**简单可靠**内存回收需求
- **设计权衡**：牺牲**并发性能**换取**实现简单性**和**内存开销最小化**
- **适用场景**：客户端应用、小型应用、内存受限环境

**Parallel 收集器**：
- **核心痛点**：多核环境下的**吞吐量最大化**需求
- **设计权衡**：牺牲**响应时间**换取**整体吞吐量**和**多核利用率**
- **适用场景**：批处理应用、科学计算、后台服务

**CMS 收集器**：
- **核心痛点**：低延迟应用的**响应时间敏感**需求
- **设计权衡**：牺牲**吞吐量**和**内存效率**换取**低停顿时间**
- **适用场景**：Web 服务器、交互式应用、实时系统

**G1 收集器**：
- **核心痛点**：大内存应用的**延迟可控**和**吞吐量平衡**需求
- **设计权衡**：通过**分区管理**和**增量回收**实现**延迟与吞吐量的统一**
- **适用场景**：大型企业应用、微服务架构、云原生应用

**ZGC 收集器**：
- **核心痛点**：超大内存应用的**极低延迟**需求
- **设计权衡**：通过**并发回收**和**着色指针**技术实现**延迟与堆大小解耦**
- **适用场景**：高频交易、实时分析、大数据处理

### 设计初衷与演进逻辑

垃圾收集器的演进反映了 Java 应用场景的**历史变迁**：从早期的**单核客户端**应用，到**多核服务器**应用，再到现代的**云原生大规模**应用。每一代收集器都在前一代的基础上，针对**新的硬件特征**和**应用需求**进行**算法创新**和**工程优化**，体现了 JVM 团队对**性能工程**的持续追求和对**用户体验**的深度理解。

---

## 【详细讲解】

### 设计理念与技术演进

垃圾收集器的设计演进遵循着**从简单到复杂**、**从串行到并行**、**从全局到局部**的技术发展轨迹。根据 JVM 规范和 HotSpot 虚拟机的官方文档，每一代收集器都在**算法复杂度**、**硬件利用率**和**应用适应性**之间寻求最佳平衡点。

**Serial 收集器**代表了垃圾回收的**经典实现**。其设计理念基于**单线程顺序处理**的简洁性原则，采用**标记-复制**算法处理新生代，**标记-整理**算法处理老年代。这种设计确保了**算法正确性**的最大化，同时将**实现复杂度**降到最低。在内存受限的环境中，Serial 收集器的**低内存开销**特性使其仍然具有重要价值。

**Parallel 收集器**的设计理念体现了对**多核硬件**的充分利用。通过**工作窃取算法**和**任务分割技术**，Parallel 收集器将垃圾回收工作分配给多个线程并行执行。其核心创新在于**分代并行处理**：新生代使用**Parallel Scavenge**算法，老年代使用**Parallel Old**算法，两者协同工作实现**全堆并行回收**。这种设计在**CPU 密集型**应用中能够显著提升整体吞吐量。

**CMS 收集器**引入了**并发回收**的革命性概念。其设计理念基于**增量标记**和**并发清除**，将垃圾回收过程分解为**初始标记**、**并发标记**、**重新标记**、**并发清除**四个阶段。通过**三色标记算法**和**写屏障技术**，CMS 实现了在应用线程运行的同时进行垃圾回收，显著降低了**停顿时间**。然而，CMS 的**标记-清除**算法会产生**内存碎片**，这成为其主要限制。

**G1 收集器**代表了垃圾回收技术的**重大突破**。其设计理念基于**分区收集**和**增量回收**，将整个堆内存划分为多个**固定大小的区域**（Region），每个区域可以独立进行垃圾回收。G1 的核心创新包括**记忆集**（Remembered Set）技术用于跨区域引用跟踪，**收集集合**（Collection Set）机制用于动态选择回收区域，以及**停顿预测模型**用于控制回收时间。这种设计实现了**可预测的低延迟**目标。

**ZGC 收集器**体现了**下一代垃圾回收**的技术前沿。其设计理念基于**并发回收**和**着色指针**技术，通过在**对象指针**中嵌入**标记信息**，实现了**无需停顿的并发标记和移动**。ZGC 的关键技术包括**多重映射**用于并发访问，**加载屏障**用于指针解引用，以及**分代 ZGC**用于进一步优化性能。这种设计使得**停顿时间与堆大小完全解耦**。

### 核心算法与实现机制

各代垃圾收集器在**算法选择**和**实现策略**上体现了不同的技术路径和工程考量。

**Serial 收集器的实现机制**相对简单但高效。在新生代，采用**复制算法**将存活对象从 Eden 区和 From Survivor 区复制到 To Survivor 区，然后清空原区域。在老年代，采用**标记-整理算法**首先标记所有存活对象，然后将它们向内存的一端移动，最后清理边界外的内存。整个过程采用**单线程顺序执行**，确保了算法的**确定性**和**可预测性**。

**Parallel 收集器的并行化实现**基于**任务分解**和**工作负载均衡**。收集器将堆内存按照**逻辑区域**或**对象数量**进行分割，每个工作线程负责处理特定的内存区域。通过**工作窃取队列**，空闲线程可以从繁忙线程中获取任务，实现**动态负载均衡**。并行化的关键挑战在于**线程同步**和**数据竞争**的处理，Parallel 收集器通过**细粒度锁**和**无锁算法**来最小化同步开销。

**CMS 收集器的并发机制**是其技术核心。**初始标记阶段**需要短暂停顿来标记 GC Roots 直接关联的对象。**并发标记阶段**使用**三色标记算法**，将对象标记为白色（未访问）、灰色（已访问但子对象未访问）、黑色（已访问且子对象已访问）。**重新标记阶段**处理并发标记期间的**引用变更**，使用**写屏障**记录的**修改记录**进行增量更新。**并发清除阶段**回收白色对象的内存空间。

**G1 收集器的分区管理**实现了**细粒度的内存控制**。每个 Region 的大小通常为 1MB 到 32MB，G1 维护每个 Region 的**存活率统计**和**回收价值评估**。**记忆集**使用**卡表**和**PRT**（Per-Region Table）来记录跨 Region 的引用关系，避免全堆扫描。**停顿预测模型**基于**历史统计数据**和**机器学习算法**，动态调整每次回收的 Region 数量以满足停顿时间目标。

**ZGC 收集器的着色指针技术**是其最大创新。在 64 位平台上，ZGC 使用指针的**高位比特**来存储对象的**标记信息**和**重定位信息**。通过**多重映射技术**，同一块物理内存可以通过不同的虚拟地址进行访问，每个虚拟地址对应不同的**颜色状态**。**加载屏障**在每次对象访问时检查指针颜色，如果发现对象已被移动，则自动更新指针并访问新位置。

### 性能特征与适用场景分析

根据 Oracle 官方的性能测试报告和工业界的实际应用数据，不同垃圾收集器在**吞吐量**、**延迟**、**内存开销**等维度上表现出显著差异。

**Serial 收集器**在**单核环境**和**小堆内存**（小于 100MB）场景下表现最佳。其**吞吐量损失**通常在 5-10% 范围内，**停顿时间**与堆大小成正比，通常在几毫秒到几十毫秒之间。Serial 收集器的**内存开销**最小，额外内存消耗通常不超过堆大小的 2%。

**Parallel 收集器**在**多核环境**和**吞吐量优先**的应用中表现出色。在 8 核服务器上，Parallel 收集器相比 Serial 收集器可以提升 **6-7 倍**的垃圾回收性能。其**吞吐量损失**通常在 1-5% 范围内，但**停顿时间**可能达到数百毫秒甚至数秒。Parallel 收集器的**内存开销**适中，额外内存消耗通常在堆大小的 5-10% 之间。

**CMS 收集器**在**响应时间敏感**的应用中具有明显优势。其**平均停顿时间**通常控制在 50-200 毫秒范围内，**99% 停顿时间**可以控制在 500 毫秒以内。然而，CMS 的**吞吐量损失**相对较高，通常在 10-30% 范围内。由于**内存碎片**问题，CMS 需要预留 **20-30%** 的额外内存空间。

**G1 收集器**实现了**延迟与吞吐量的平衡**。在 4GB 以上的大堆内存中，G1 可以将**停顿时间**控制在用户设定的目标范围内（通常 10-200 毫秒），同时保持较高的**吞吐量**（吞吐量损失通常在 5-15% 范围内）。G1 的**内存开销**相对较高，额外内存消耗通常在堆大小的 10-20% 之间，主要用于维护**记忆集**和**区域管理**数据结构。

**ZGC 收集器**在**超低延迟**方面表现卓越。无论堆大小如何（从 8MB 到 16TB），ZGC 的**停顿时间**都能稳定控制在 **10 毫秒以内**，**99.9% 停顿时间**通常在 1 毫秒以内。ZGC 的**吞吐量损失**在不断优化中，目前通常在 5-20% 范围内。ZGC 的**内存开销**相对较高，额外内存消耗通常在堆大小的 15-25% 之间。

### 演进历史与技术对比

垃圾收集器的演进历史反映了 Java 生态系统的**技术进步**和**应用需求变化**。

**第一代收集器**（Serial、Parallel）主要解决**功能可用性**问题，确保垃圾回收的**正确性**和**基本性能**。这个阶段的重点是**算法实现**和**多核利用**，为 Java 在服务器端的广泛应用奠定了基础。

**第二代收集器**（CMS）引入了**并发回收**概念，开始关注**用户体验**和**响应时间**。CMS 的出现标志着垃圾回收技术从**吞吐量优先**向**延迟敏感**的转变，推动了 Java 在**交互式应用**和**Web 服务**领域的发展。

**第三代收集器**（G1）实现了**延迟可控**的目标，通过**分区管理**和**增量回收**技术，使得 Java 能够支持**大内存应用**和**企业级系统**。G1 的成功验证了**预测式垃圾回收**的可行性。

**第四代收集器**（ZGC、Shenandoah）追求**极致性能**，通过**并发移动**和**着色指针**等前沿技术，将垃圾回收的**停顿时间**降低到**亚毫秒级别**，为 Java 在**高频交易**、**实时系统**等领域的应用开辟了新的可能性。

从技术发展趋势来看，未来的垃圾收集器将更加注重**自适应性**、**可观测性**和**云原生特性**。**分代 ZGC**、**并行 G1**等技术正在开发中，预期将进一步提升性能和适用性。同时，**机器学习**技术在垃圾回收中的应用也在探索中，有望实现更智能的**内存管理**和**性能优化**。

### 生产环境选择与调优策略

在实际的生产环境中，垃圾收集器的选择需要综合考虑**应用特征**、**硬件环境**、**性能目标**等多个因素。

**应用特征分析**是选择的基础。**批处理应用**通常选择 Parallel 收集器以最大化吞吐量；**Web 应用**通常选择 G1 或 CMS 以控制响应时间；**实时应用**通常选择 ZGC 以最小化延迟；**内存受限应用**通常选择 Serial 以减少开销。

**硬件环境适配**同样重要。**单核或双核**环境适合 Serial 收集器；**多核环境**（4-8 核）适合 Parallel 或 G1 收集器；**高核数环境**（16 核以上）适合 G1 或 ZGC 收集器；**大内存环境**（8GB 以上）建议使用 G1 或 ZGC 收集器。

**性能调优参数**的设置需要基于**实际测试**和**监控数据**。对于 G1 收集器，关键参数包括 `-XX:MaxGCPauseMillis` 设置停顿时间目标，`-XX:G1HeapRegionSize` 设置区域大小，`-XX:G1NewSizePercent` 设置新生代比例。对于 ZGC 收集器，主要参数包括 `-XX:+UseZGC` 启用 ZGC，`-XX:+UnlockExperimentalVMOptions` 解锁实验特性。

**监控和诊断**是持续优化的关键。可以使用 **GCeasy**、**GCPlot** 等工具分析 GC 日志，使用 **JFR**（Java Flight Recorder）进行详细的性能分析，使用 **jstat**、**jhsdb** 等命令行工具进行实时监控。关键监控指标包括**GC 频率**、**停顿时间分布**、**吞吐量变化**、**内存使用模式**等。

---

**相关阅读**：
- [JVM 内存结构 (运行时数据区)](./jvm-memory-structure.md)
- [垃圾回收算法：标记-清除、复制、标记-整理](./garbage-collection-algorithms.md)
- [对象的创建过程、内存布局与访问定位](./object-creation-and-memory-layout.md)

**下一步**：深入学习 [内存泄漏与内存溢出的诊断与解决](./memory-leak-and-oom-diagnosis.md)，掌握生产环境中的内存问题排查技能。 